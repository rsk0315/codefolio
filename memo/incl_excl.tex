\documentclass{jsarticle}

\usepackage{rsk0315}

\begin{document}
\section{包除原理}

数え上げのテクニックの一つ．
集合$A$が与えられ，その要素を変数とする述語たち$\mathcal{P}=\{P_1, \dots, P_k\}$を考える．
$1\le i\le k$に対して$A$の部分集合$A_i$を$A_i=\{a\in A\mid P_i(a)\}$で定めるとき，$\bigcup_{i=1}^k A_i$の要素数を求めるものである．
$\Lambda_K=\{1, \dots, k\}$とする．
\begin{align}\label{eqn:base}
\left|\bigcup_{i=1}^k A_i\right|
= \sum_{\emptyset\subset\Lambda\subseteq \Lambda_K} (-1)^{|\Lambda|-1}\cdot \left|\bigcap_{i\in\Lambda} A_i\right|.
\end{align}
$|\Lambda|=|\Lambda'|\implies\left|\bigcap_{i\in\Lambda}A_i\right| = \left|\bigcap_{i\in\Lambda'}A_i\right|$であるなら，$|\Lambda|=j$であるような$\Lambda$の代表元を$\Lambda^j$と書くことにして次のように変形できる．
\begin{align}\label{eqn:linear}
  \left|\bigcup_{i=1}^k A_i\right|
  = \sum_{j=1}^k (-1)^{j-1}\cdot {}_k C_j\cdot\left|\bigcap_{i\in\Lambda^j}A_i\right|.
\end{align}
式(\ref{eqn:base})においては$\sum$で足し合わされる項が$2^k-1$個だったのに対し，式(\ref{eqn:linear})では$k$に減っていてうれしい．

上の議論は，$\left|\bigcap_{i\in\Lambda}A_i\right|$を計算するのが容易であることを前提としているが，逆に$\left|\bigcap_{i\in\Lambda}(A\setminus A_i)\right|$の計算が容易な状況\footnote{満たす条件を決め打ちするよりも，満たさない条件を決め打ちした方が楽な場合．}
で$\bigcap_{i=1}^k A_i$の要素数を求めたいときには以下のようにするとよい．
\[
\bigcap_{i=1}^k A_i = A\setminus\left(\bigcup_{i=1}^k (A\setminus A_i)\right).
\]
すなわち，
\[
\left|\bigcap_{i=1}^k A_i\right| = |A|-\left|\left(\bigcup_{i=1}^k (A\setminus A_i)\right)\right|.
\]
これは，$A\setminus A_i$を$A_i$と置き直すことで，式(\ref{eqn:base})の枠組みで求められる．

\subsection{証明}
\begin{align*}
  \left|\bigcup_{i=1}^k A_i\right| &= \left|\left(\bigcup_{i=1}^{k-1} A_i\right)\cup A_k\right|\\
  &= \left|\bigcup_{i=1}^{k-1} A_i\right| + |A_k| - \left|\left(\bigcup_{i=1}^{k-1} A_i\right)\cap A_k\right|\\
  &= \left|\bigcup_{i=1}^{k-1} A_i\right| + |A_k| - \left|\bigcup_{i=1}^{k-1} (A_i\cap A_k)\right|\\
\end{align*}
ここで，右辺の第1項と第3項を展開すると次のようになる．
\begin{align*}
  \left|\bigcup_{i=1}^{k-1} A_i\right|
  &= \sum_{\emptyset\subset\Lambda\subseteq\Lambda_{k-1}} (-1)^{|\Lambda|-1} \cdot\left|\bigcap_{i\in\Lambda} A_i\right|.
\end{align*}
\begin{align*}
  -\left|\bigcup_{i=1}^{k-1} (A_i\cap A_k)\right|
  &= -\sum_{\emptyset\subset\Lambda\subseteq\Lambda_{k-1}} (-1)^{|\Lambda|-1} \cdot\left|\bigcap_{i\in\Lambda} (A_i\cap A_k)\right|\\
  &= -\sum_{\emptyset\subset\Lambda\subseteq\Lambda_{k-1}} (-1)^{|\Lambda|-1} \cdot\left|\left(\bigcap_{i\in\Lambda} A_i\right)\cap A_k\right|.
\end{align*}
これらより，
\begin{align*}
  \left|\bigcup_{i=1}^k A_i\right|
  &= \sum_{\emptyset\subset\Lambda\subseteq\Lambda_k} (-1)^{|\Lambda|-1} \cdot\left|\bigcap_{i\in\Lambda} A_i\right|.
\end{align*}

\subsection{発展}
\subsubsection{高速ゼータ変換・高速M\"obius変換}
高速ゼータ変換は，集合$S$の部分集合を引数に取る関数$f$に対して$g(S)=\sum_{T\subseteq S} f(T)$を$O(|S|\cdot 2^{|S|})$時間で求める．
高速M\"obius変換はその逆変換に相当し，$f(S)=\sum_{T\subseteq S} (-1)^{|S\setminus T|}\cdot g(T)$を求める．
\begin{minted}{c++}
  // fast zeta transformation
  for (size_type i = 0; i < n; ++i)
    for (size_type j = 0; j < (1_zu << n); ++j)
      if (j >> i & 1_zu) dp[j] += dp[j ^ (1_zu << i)];
\end{minted}
\begin{minted}{c++}
  // fast Moebius transformation
  for (size_type i = 0; i < n; ++i)
    for (size_type j = 0; j < (1_zu << n); ++j)
      if (j >> i & 1_zu) dp[j] -= dp[j ^ (1_zu << i)];
\end{minted}
各\texttt{j}について$\mathtt{dp}[\mathtt{j}] = f(\mathtt{j})$で初期化し，ゼータ変換を施すと$\mathtt{dp}[\mathtt{j}] = g(\mathtt{j})$になっている．M\"obius変換についても$g$と$f$が逆になること以外は同様である．
ここで，\texttt{j}は部分集合をbitでエンコードしたものである．

たとえば，$\Lambda_k$の各部分集合$S$に対して$\sum_{T\subseteq S} (-1)^{|T|}\cdot \left|\bigcap_{i\in T}A_i\right|$を考える．
これは，$g(T) = \left|\bigcap_{i\in T} A_i\right|$として高速M\"obius変換で得られる$f(S)$を用いて$(-1)^{|S|}\cdot f(S)$として計算できる．


\subsection{補足}
\subsubsection{暗黙の制約}
$n\le 10^9$，$n\le 10^{18}$なら$n$の持つ素因数の個数はそれぞれ，たかだか$9$個，$15$個なので，$n$が多少大きくても$n$の素因数に関する部分集合であれば式(\ref{eqn:base})をそのまま計算することができる．

\end{document}
