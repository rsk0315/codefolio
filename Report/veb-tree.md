## van Emde Boas tree
### 2018年7月9日

整数の集合の演算を高速に行うデータ構造．通常の演算（insertion/erasure/membership）に加え，ある値$x$を超える最小の値を求めるsuccessor，その逆のpredecessorを得る演算と，最小値・最大値を求める演算も行える．
$[0, U-1]$の区間の整数を全体集合とする．boundされた整数の集合を扱うデータ構造であり，multisetやmapとして使おうとするのは険しい．

全体を陽に持つとメモリがやばいので動的に確保するが，概念としては木構造になっている．
根ノードは$\sqrt{U}$個の子を持ち，その子は$\sqrt{\sqrt{U}}$個の子を持つ（以下同様）．
端数が出ると厄介なので，$U=2^{(2^n)}$としておく．
各ノードは区間の一部分を管理していて，$[0, u-1]$を管理しているノードの$i$番目（0-indexed）の子ノードは$[i\sqrt{u}, (i+1)\sqrt{u}-1]$を管理している．
実装の際には，各子ノードは$[0, \sqrt{u}-1]$を管理する集合とし，$i$番目の子ノードが値$j$を持っていれば元のノードは$i\sqrt{u}+j$を持っていると判断するようにする．

各ノードが持っているデータは次の三つである．
- そのノードが持つ集合の最小値$m$・最大値$M$
- 子ノードたちへのポインタ
- summaryと呼ばれる集合（後述）

$[0, u-1]$を管理するノード$v$の持つsummary $s$は$[0, \sqrt{u}-1]$の区間を管理するノード（すなわち$v$の各子ノード）と同じ構造を持っていて，$i\in s$であることと，$v$の$i$番目の子ノードの持つ集合が空でないことが同値となるように保たせる．

ノード$v$が管理する区間に含まれる要素数によって，データの持ち方は異なる．
要素数が$2$以下のときは$m$と$M$のみを用いて表現し，$s$や子ノードたちは空とする．

$v$が持つ集合の要素を昇順に$\{a_1, a_2, \ldots, a_n\}$とする．
$n=0$のときは$m>M$など，それ以外の状態では取り得ない状態にしておく．
$n=1$のときは$m=M=a_1$とし，$n=2$のときは$m=a_1$，$M=a_2$とする．
$n\ge 3$のときは$m=a_1$，$M=a_n$として，各子ノードを用いて$\{a_2, \ldots, a_{n-1}\}$を表現する（子ノードには$a_1$および$a_n$は含めない）．

これのお気持ちになるとあとは簡単で，これを保つように変更したり，これを元にして探索すればよい．successorについては少々頭が必要で，以下のような処理をする．クエリを$x$とする．
- $x\ge M$や$M<m$であれば該当する要素は存在しない．
  - $x$を返してエラーを示すとか，例外を投げるとかをする．
- $x<m$なら$m$を返す．
- 子ノードが空なら$M$を返す．
- $x$が入るべき子ノードの持つ最大値が$x$を超えていれば，その子ノードに該当する要素が含まれるので，そのノードを探索する．
  - 該当する子ノードの添字$i$は$\lfloor x/\sqrt{U}\rfloor$となる．
- $s$の最大値が$i$以下であれば，$M$を返す．
- $s$における$i$のsuccessor $j$を求め，$j$番目の子ノードの最小値を返す．


$U=256$程度であれば，$64$-bit整数$4$つをbitsetとして扱うことで集合を表現できるため，それを利用した．$64$-bit整数$1$つで持って各階層のノード数を$\{64, 4096, 16777216, \ldots\}$とした場合，$2^{64}$と噛み合わなくなるのが嫌だったのでこのようにしてある．$U=16$のときに特殊化する実装と$U=256$のときに特殊化する実装を比較したところ，後者の方が高速であった．

AOJのLessonの`ITP2_7_C`でverify．大きい値側から求めて逆向きに出力することでpredecessorについてもverify済み．minやmaxは陽にはverifyしていないが，まぁ合っている気がする（えー）．

ちなみに実測で`std::set`に勝てていません（最悪ケース時）．ケースによっては勝っているものもありますが，競プロにおいては最も時間がかかるものが指標になってしまうため．$i$番目の子ノードを管理するのに`std::map`を使っているんだけど，そこを工夫できると嬉しい？
