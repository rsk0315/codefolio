## 赤黒木
### 2018年8月5日

平衡二分木で，`std::set<T>`などにも使われているデータ構造．
2-3-4木と非常によく似ている．

順序を保って平衡二分探索木として使うことで通常の演算（insertion/erasure/membership/successor/predecessorなど）を高速に行えるほか，区間に対する処理を高速に行える配列として（任意の順序で）値を持っておくことも可能．
以前D.C.のonlineアルゴリズムでは後者として利用した．

以下の性質を保つことで，平衡を保証している．
- 各ノードは黒色または赤色である
- 根ノードは黒色である
- 赤色のノードの子は黒色である
- 根から葉までのどのパスにおいても，現れる黒色のノードの個数は等しい
- （&\textsc{Nil}&ノードは黒色である）


ノードの挿入・削除の際は，回転させたりしてこの条件を満たすように修正する[^rb_balance]．
$u$を挿入した後，それより上のノードを修正する関数を`insert-fix-up`$(u)$とする．
削除後の修正関数`erase-fix-up`$(u)$の$u$がどのノードに相当するかはお絵かきが必要．
#[^rb_balance]: 詳細は略．お絵かきすると気持ちがわかってくるはず．
子ノードへのポインタを持つときに`Node *left, *right;`とすると同じような処理を複数回書く必要があって大変なので，向きを$0$と$1$に対応づけて`Node *children[2];`としておくと実装が楽．

また，あるノード$v$を基準として左右に分ける`split`$(v)$や，あるノード$v$を仲介して別の赤黒木$T$とくっつける`merge`$(T, v)$もできる．
赤黒木同士を直接くっつけたい場合は$T$の最初のノードを外し，それを$v$として`merge`すればよい．

`merge`$(T, v)$ですることは，以下の通りである．
$T$の方が自身より低いとして話を進めるが，逆の場合（等しい場合を含む）は適宜注意すること．
- $T$の根から根ノードまでの黒色ノードの個数を数える
- 自身の根から右端のノードのうち，以下を満たすノード$u$を見つける
  - 黒色ノードである    
  - 自分（inclusive）から根までの黒色ノードの個数が上で数えた個数と等しい
- このノード$u$と$T$の根を$v$の子とし，$u$の元の親を$v$の親とする
- $v$を赤色にし，`insert-fix-up`$(v)$をする．


`split`$(v)$ですることは，以下の通りである．
- $v$の左右の部分木をそれぞれ$T_L$，$T_R$とする
- $v$が根になるまで以下を繰り返す
  - $v$の親を$v_P$，$v$の姉妹以下の部分木を$T_S$とする
  - $v$が$v_P$の右の子なら，$T_L$を`merge`によって$\langle T_S, v_P, T_L\rangle$にする
  - $v$が$v_P$の左の子なら，$T_R$を`merge`によって$\langle T_R, v_P, R_S\rangle$にする


また，自分の左の部分木のノード数を各ノードに持たせておくことで，$i$番目のノードに$O(\log n)$でアクセスすることが可能だが，各種操作をする際に適切に管理する必要がある．
さらに，自分の両方の部分木のノードたちの最小の値を持たせておくことで，区間$[i_L, i_R]$内の最小値を$O(\log n)$で取得することが可能だが，これも適切に管理する必要があり，気をつける必要がある．

